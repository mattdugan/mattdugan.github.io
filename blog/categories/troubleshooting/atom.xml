<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Troubleshooting | Matt Dugan]]></title>
  <link href="http://mattdugan.github.io/blog/categories/troubleshooting/atom.xml" rel="self"/>
  <link href="http://mattdugan.github.io/"/>
  <updated>2013-07-11T17:26:36-04:00</updated>
  <id>http://mattdugan.github.io/</id>
  <author>
    <name><![CDATA[Matt Dugan]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[JUDCon 2013: Full Control &amp; Transparency]]></title>
    <link href="http://mattdugan.github.io/blog/2013/06/25/judcon-2013-full-control-and-transparency/"/>
    <updated>2013-06-25T12:09:00-04:00</updated>
    <id>http://mattdugan.github.io/blog/2013/06/25/judcon-2013-full-control-and-transparency</id>
    <content type="html"><![CDATA[<p>Josh West and Andrew Dinn gave a well informed talk on various code and
runtime inspection tools in the JBoss toolbox.  First up was
<a href="https://www.jboss.org/tattletale">JBoss Tattletale</a>, used to inspect and
capture metadata for applications.  Tattletale creates an inventory of
all the libraries in and application and allows you to easily find which
jar is containing a class you have reason to be concerned with.  Ask anyone
who has tried to use the various online &ldquo;jar finder&rdquo; kinds of services and
they will tell you that being able to see a specific, context relevant
listing is a secret sauce.  Personally, I&rsquo;m glad to find a tool that allows
me to finally throw away my quick and dirty scripts combining find, unzip and
grep to look for class locations.  Tattletale creates and easy to search and
read report in HTML and can be invoked within your continous integration
build tool of choice so that reports are always at the ready.</p>

<p><a href="https://windup.jboss.org/index.html">JBoss Windup</a>, a tool I am personally
excited about to assist with inventory of applications deployed to Oracle or
IBM application servers produces output from Tattletale as one of its
artifacts.</p>

<h2>Decompiling</h2>

<p>Next, we looked briefly at decompilation options for code that you either
didn&rsquo;t write or don&rsquo;t own or (Heaven forbid) don&rsquo;t have the source code for
any longer.  <a href="http://java.decompiler.free.fr/?q=jdgui">JD-GUI</a> seems to be
the best of the readily available options, but itself is not open source. Of
course, that leaves you to wonder the obvious question of when you might need
to decompile the decompiler.  There is an open source JAVA decompiler in the
works, called <a href="https://github.com/bradsdavis/candle-decompiler">Candle</a> by
Brad Davis, the author of Cake, the tool behind Windup.</p>

<h2>Bytecode Magic</h2>

<p>This section could just as easily have been called <em>Black Magic</em>.  Bytecode
injection is a technique that not many leverage because it is simultaneously
powerful and tough to get right if you don&rsquo;t know exactly what you are doing.</p>

<p><a href="http://www.jboss.org/byteman">Byteman</a> gives you the capability to inject
code at <em>RUNTIME</em> within just about any bit of code you have running, whether
you wrote it or not.  In a fantastic bit of functionality, this capability is
delivered as a <em>rule</em> you can define along with the code you want to be
injected and executed at the point defined by the rule.  You get local access
to variables and methods (if you know the names) so you can do detail logging
or property modification.  As a bonus, Byteman works at a lower level than
reflection, so you needn&rsquo;t worry about the public vs private nature of
class members.  While the obvious use is to inject logging and debugging
statements to better observe a problem, Byteman can also be used to assert
tests or conditions which are difficult (if not impossible) to reproduce in
a development environment.  For example, if the production environment has
a poorly handled runtime exception from time to time which cannot be
reproduced in any other environment, Byteman could be used on a developer&rsquo;s
workstation to inject the runtime exception at the exact point it is being
thrown in the live environment and develop proper handling and application
recovery.</p>

<p>Continuing to wax enthusiastic about Byteman, it has the ability to run as
an Agent on the JVM when passed as a command line parameter on startup,
allowing it to listen on a remote interface for live inspection of the
execution environment.  Rules submitted this way can be typechecked, so you
can be fairly certain that they will not cause a runtime error when
encountered.  However, the important thing to note is that if you are using
a very specific type, such as a particular kind of exception, be sure to
use the fully qualified name so as to avoid unexpected results if the
application has defined a local type with the same name that is in scope
of the executing rule, or in case the type is not already imported by the
parent class.</p>

<h2>Closing Thoughts</h2>

<p>With runtime modification and injection, Java developers can get a taste of
4GL without leaving their cozy strongly typed 3rd generation language.</p>
]]></content>
  </entry>
  
</feed>
